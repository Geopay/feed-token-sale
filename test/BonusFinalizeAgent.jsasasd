'use strict';

const assertJump = require('./helpers/assertJump');
var Token = artifacts.require("./helpers/UpgradeableTokenMock.sol");
var bonusContract = artifacts.require("../contracts/BonusFinalizeAgent.sol");

function etherInWei(x) {
    return web3.toBigNumber(web3.toWei(x, 'ether')).toNumber();
}


function tokenPriceInWeiFromTokensPerEther(x) {
    if (x == 0) return 0;
    return Math.floor(web3.toWei(1, 'ether') / x);
}

function tokenInSmallestUnit(tokens, _tokenDecimals) {
    return tokens * Math.pow(10, _tokenDecimals);
}

contract('BonusFinalizeAgent', function(accounts) {
    _teamAddresses = [accounts[0], accounts[1], accounts[2]];
    var _teamBonusPoints = [200, 200, 200];

    console.log(_tranches);

    beforeEach(async() => {
        bonusAgent = await bonusContract.new(accounts[3], accounts[4],_teamAddresses, _teamBonusPoints { from: accounts[0] });
    });

    it('Creation: Pricing tranches count must be able to initialized properly.', async function() {
        assert.equal(await bonusAgent.trancheCount.call(), _tranches.length / 2);
    });

    it('Creation: Pricing tranches must be able to initialized properly.', async function() {
        var i = 0;
        for (i = 0; i < _tranches.length / 2; i = i + 2) {
            var data = await pricing.tranches.call(i);
            assert.equal(web3.toBigNumber(data[0]).toNumber(), _tranches[i]);
            assert.equal(web3.toBigNumber(data[1]).toNumber(), _tranches[i + 1]);
        }
    });

    it('PreICOAddress: Owner must be able to set pre ICO address.', async function() {
        await pricing.setPreicoAddress(accounts[3], tokenPriceInWeiFromTokensPerEther(2000));
    });

    it('PreICOAddress: Non-Onwer must be not able to set pre ICO address.', async function() {
        try {
            await pricing.setPreicoAddress(accounts[3], tokenPriceInWeiFromTokensPerEther(2000), { from: accounts[2] });
        } catch (error) {
            return assertJump(error);
        }
        assert.fail('should have thrown exception before');
    });

    it('Calculation: Pricing must be calculated properly.', async function() {
        await pricing.setPreicoAddress(accounts[3], tokenPriceInWeiFromTokensPerEther(2000));


        assert.equal(web3.toBigNumber(await pricing.calculatePrice(etherInWei(1), etherInWei(0), tokenInSmallestUnit(0, _tokenDecimals), accounts[1], _tokenDecimals)).toNumber(), tokenPriceInWeiFromTokensPerEther(1500) * 1);

        assert.equal(web3.toBigNumber(await pricing.calculatePrice(etherInWei(1), etherInWei(3), tokenInSmallestUnit(4500, _tokenDecimals), accounts[2], _tokenDecimals)).toNumber(), tokenPriceInWeiFromTokensPerEther(1500) * 1);
        assert.equal(web3.toBigNumber(await pricing.calculatePrice(etherInWei(3), etherInWei(7), tokenInSmallestUnit(10100, _tokenDecimals), accounts[2], _tokenDecimals)).toNumber(), tokenPriceInWeiFromTokensPerEther(1300) * 3);
        assert.equal(web3.toBigNumber(await pricing.calculatePrice(etherInWei(1.4), etherInWei(12.556), tokenInSmallestUnit(16811.6, _tokenDecimals), accounts[2], _tokenDecimals)).toNumber(), tokenPriceInWeiFromTokensPerEther(1100) * 1.4);

        assert.equal(web3.toBigNumber(await pricing.calculatePrice(etherInWei(5.4), etherInWei(18.006), tokenInSmallestUnit(22656.3, _tokenDecimals), accounts[2], _tokenDecimals)).toNumber(), tokenPriceInWeiFromTokensPerEther(1050) * 5.4);
        assert.equal(web3.toBigNumber(await pricing.calculatePrice(etherInWei(10.56373), etherInWei(108.14938826), tokenInSmallestUnit(112899.38826, _tokenDecimals), accounts[2], _tokenDecimals)).toNumber(), tokenPriceInWeiFromTokensPerEther(1000) * 10.56373);
        assert.equal(web3.toBigNumber(await pricing.calculatePrice(etherInWei(1.4), etherInWei(318.006), tokenInSmallestUnit(22656.3, _tokenDecimals), accounts[2], _tokenDecimals)).toNumber(), 0);
    });

    it('Calculation: Pricing for pre ico user must be calculated properly.', async function() {
        await pricing.setPreicoAddress(accounts[3], tokenPriceInWeiFromTokensPerEther(2000));
        assert.equal(web3.toBigNumber(await pricing.calculatePrice(etherInWei(1.4), etherInWei(12.556), tokenInSmallestUnit(16811.6, _tokenDecimals), accounts[3], _tokenDecimals)).toNumber(), tokenPriceInWeiFromTokensPerEther(2000) * 1.4);
    });

    it('Transfer: ether transfer to pricing address should fail.', async function() {

        try {
            await web3.eth.sendTransaction({ from: accounts[0], to: pricing.address, value: web3.toWei("10", "Ether") });
        } catch (error) {
            return assertJump(error);
        }
        assert.fail('should have thrown exception before');
    });




});